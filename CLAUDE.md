# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Repository Overview

This is a Nix-managed workspace containing multiple MCP (Model Context Protocol) projects written in Rust. The repository includes:

- **mcp-basic-server**: A basic MCP server implementation demonstrating the rmcp SDK
- **rust-sdk**: The official Rust MCP SDK (rmcp crate) with procedural macros
- **servers**: Reference MCP server implementations (TypeScript/JavaScript)
- **rmcp-openapi**: OpenAPI specification to MCP tools conversion library and server
- **quick-start**: Root-level Rust workspace configuration

## Build and Development Commands

All commands should be run through the Nix development environment using `nix develop -c`.

### Building

```sh
# Build the entire workspace
nix develop -c cargo build

# Build in release mode
nix develop -c cargo build --release

# Build specific package
nix develop -c cargo build -p mcp-basic-server

# Build with Nix (creates result symlink)
nix build
```

### Testing

```sh
# Run tests with cargo-nextest (preferred)
nix develop -c cargo nextest run

# Run tests with standard cargo test
nix develop -c cargo test

# Run tests for specific package
nix develop -c cargo nextest run -p rmcp

# Run specific test
nix develop -c cargo nextest run test_name
```

### Code Quality

```sh
# Format Rust code
nix develop -c cargo fmt

# Format TOML files (uses taplo)
nix develop -c taplo fmt

# Format everything with nix
nix fmt

# Run clippy linter
nix develop -c cargo clippy --all-targets -- --deny warnings

# Audit dependencies for security issues
nix develop -c cargo audit

# Check license compliance
nix develop -c cargo deny check
```

### Running the MCP Server

```sh
# Run the basic MCP server with stdio transport
nix develop -c cargo run -p mcp-basic-server --features transport-io

# Run with logging (stderr output)
RUST_LOG=debug nix develop -c cargo run -p mcp-basic-server --features transport-io

# Test with MCP inspector (requires npx)
npx @modelcontextprotocol/inspector nix develop -c cargo run -p mcp-basic-server --features transport-io
```

### Nix Flake Checks

```sh
# Run all Nix checks (builds, clippy, docs, formatting, tests, audit, deny)
nix flake check

# Run specific check
nix build .#checks.x86_64-linux.quick-start-clippy
nix build .#checks.x86_64-linux.quick-start-nextest
```

## Architecture

### MCP Basic Server (mcp-basic-server)

A demonstration MCP server using the rmcp SDK with the following components:

- **main.rs**: Entry point that sets up tracing, creates the Counter service, and serves over stdio transport
- **common/counter.rs**: Example MCP server implementation with:
  - Tool handlers: increment, decrement, get_value, say_hello, echo, sum
  - Prompt handlers: example_prompt, counter_analysis
  - Resource handlers: list_resources, read_resource
  - Uses procedural macros (#[tool_router], #[prompt_router], #[tool], #[prompt])

Key patterns:
- Tools are defined with `#[tool]` macro on impl methods
- Prompts are defined with `#[prompt]` macro
- `ServerHandler` trait implementation provides MCP protocol methods
- State (counter) is shared via `Arc<Mutex<T>>`
- Uses tokio async runtime throughout

### RMCP SDK (rust-sdk)

The official Rust implementation of the Model Context Protocol with:

- **rmcp**: Core MCP protocol implementation with features:
  - `server`: Server-side MCP implementation
  - `client`: Client-side MCP implementation
  - `transport-io`: Stdio transport for MCP communication
  - `server-side-http`: HTTP/SSE transport support
- **rmcp-macros**: Procedural macros for generating tool/prompt implementations
  - `#[tool_router]`, `#[prompt_router]`: Generate router structs
  - `#[tool]`, `#[prompt]`: Mark handler methods
  - `#[tool_handler]`, `#[prompt_handler]`: Implement protocol traits

Transport options:
- stdio (stdin/stdout) - most common for MCP servers
- HTTP with SSE or StreamableHttp
- Custom transports via trait implementation

### RMCP OpenAPI (rmcp-openapi)

Converts OpenAPI specifications into MCP tools:

- **rmcp-openapi** (library): Core conversion logic
- **rmcp-openapi-server** (binary): Standalone MCP server that exposes OpenAPI endpoints as tools

Security: By default operates in MCP-compliant mode and does not forward authorization headers. See SECURITY.md for authorization modes.

## Development Workflow

### Adding New Tools to MCP Server

1. Add method to the impl block with `#[tool_router]` attribute
2. Annotate method with `#[tool(description = "...")]`
3. Define parameter struct with `serde::Deserialize` and `schemars::JsonSchema`
4. Wrap parameters with `Parameters<T>` in function signature
5. Return `Result<CallToolResult, McpError>`
6. The tool_router() method is auto-generated by the macro

Example:
```rust
#[tool(description = "Add two numbers")]
fn add(&self, Parameters(AddArgs { a, b }): Parameters<AddArgs>)
    -> Result<CallToolResult, McpError> {
    Ok(CallToolResult::success(vec![Content::text((a + b).to_string())]))
}
```

### Adding New Prompts

1. Add method to impl block with `#[prompt_router]` attribute
2. Annotate with `#[prompt(name = "prompt_name")]`
3. Define argument struct with schema derives
4. Return `Result<Vec<PromptMessage>, McpError>` or `Result<GetPromptResult, McpError>`
5. Access RequestContext if needed for HTTP request details

## Workspace Structure

This is a Cargo workspace with the following layout:
- Root Cargo.toml defines workspace with mcp-basic-server as member
- Each subproject (rust-sdk, rmcp-openapi, servers) has its own workspace
- Nix flake manages build environment with crane for Rust builds
- taplo.toml configures TOML formatting to sort Cargo.toml dependencies

## Dependencies and Features

Key dependencies:
- **tokio**: Async runtime (required, use "full" features)
- **rmcp**: MCP SDK (path or git dependency)
- **serde/serde_json**: Serialization (required)
- **schemars**: JSON Schema generation for tool parameters (must use 2020-12 spec)
- **tracing/tracing-subscriber**: Logging to stderr
- **anyhow**: Error handling for applications
- **axum**: HTTP server support (optional, with server-side-http feature)

Features to enable:
- `transport-io`: For stdio transport (most common)
- `server-side-http`: For HTTP/SSE transport with axum

## Testing Patterns

The codebase includes comprehensive tests:
- Unit tests in counter.rs verify macro-generated attributes and router behavior
- Integration tests in rust-sdk/crates/rmcp/tests/ cover protocol compliance
- Use tokio::test for async tests
- Mock RequestContext with CancellationToken for testing handlers

## License and Compliance

- Projects use MIT license (enforced by deny.toml)
- cargo-audit checks for security vulnerabilities (.cargo/audit.toml)
- cargo-deny enforces license compliance
